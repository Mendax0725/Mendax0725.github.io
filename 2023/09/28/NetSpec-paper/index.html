<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zhu He">





<title>NetSpec-paper | Hexo</title>



    <link rel="icon" href="/favicon1.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Mendax&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Mendax&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">NetSpec-paper</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zhu He</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 28, 2023&nbsp;&nbsp;19:30:51</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Synthesizing-Formal-Network-Specifications-from-Input-Output-Examples"><a href="#Synthesizing-Formal-Network-Specifications-from-Input-Output-Examples" class="headerlink" title="Synthesizing Formal Network Specifications from Input-Output Examples"></a>Synthesizing Formal Network Specifications from Input-Output Examples</h1><h2 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h2><h3 id="NetSpec："><a href="#NetSpec：" class="headerlink" title="NetSpec："></a>NetSpec：</h3><p>NetSpec是一个使用声明式逻辑编程语言，能够从输入-输出示例中合成网络规范的工具。通过减少定义网络模型或属性所需的专业知识和工作，从而加速形式化验证在网络实践中的应用。</p>
<h3 id="netspec的目标："><a href="#netspec的目标：" class="headerlink" title="netspec的目标："></a>netspec的目标：</h3><p>1.  具有⾼度表达能⼒，能够综合具有复杂语义的⽹络规范；<br>2.  可扩展性，通过使⽤新颖的最佳优先搜索算法来有效地搜索没有边界的解决⽅案空间；<br>3.  鲁棒性，通过主动⽣成新⽰例，避免了对详尽的输⼊-输出⽰例的需要。</p>
<p>我们的实验表明，NetSpec 可以合成⽤于⽹络验证、分析和实现的各种规范。此外，在表达能力、对示例的鲁棒性以及合成程序的质量方面，NetSpec 都优于现有方法。</p>
<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>形式规范对于众多⽹络任务⾄关重要，包括验证[20]、[5]、[6]、[40]、[41]、分析[4]、[26]、[9]和调试[ 11]，[43]等多个方面。寻求验证⽹络属性的⽹络运营商需要⽹络协议的形式规范[20]。在云管理中，集群管理员希望确定节点可达性，必须使⽤声明性查询指定所需的⾏为[4]、[26]。在分布式系统中，程序员希望验证某些系统属性，同样依赖于各种协议的形式规范，包括域间路由[41]、[20]、[6]、共识协议[3]、[37]、和安全协议[12]。此外，各种领域特定语⾔[31]、[25]、[17]、[7]依赖于逻辑表达的形式规范作为生成实现的基础，从而弥补规范与实现的鸿沟。</p>
<p>尽管形式规范具有⼴阔的前景，但在实践中尚未获得广泛的应⽤。如今，对于⽹络从业者来说，编写这些形式规范仍然具有挑战性，确保规范涵盖⽹络的所有⽅⾯就更难了。形式化语⾔的学习曲线陡峭，很难找到同时精通⽹络操作和形式化⽅法的⼯程师。因此，尽管⽹络验证和分析⼯具取得了进步，但执⾏这些任务仍然需要形式化⽅法的专家，⾄少可以⽤形式规范语⾔编写所需的属性或对⽹络进⾏建模。</p>
<p>在本⽂中，我们提出了 NetSpec，一个通过实例编写规范的工具包(<em><strong>specification-by-example</strong></em>)，旨在逻辑上⾃动合成⽹络协议的形式规范。NetSpec 希望网络程序员即使不具备足够的形式化⽅法专业知识，能够更容易进⾏形式化⽹络分析。在 SBE 范式中，程序员提供其协议设计的输⼊输出⽰例，这些设计可以是⼿写的，也可以从实际运⾏时通信路径中派生出来。然后，NetSpec 应⽤程序综合技术来⾃动⽣成适合验证 [40] 或⽣成分布式实现 [25]的形式规范。</p>
<p>我们选择逻辑作为NetSpec的基础是因为许多形式⽹络模型都可以追溯到逻辑规范。特别是，我们研究的目标是声明式逻辑编程语⾔ Datalog [2] 的扩展，该语⾔在⽹络验证 [20]、[17]、[5]、[40]、[41]、分析 [31] ]、[4]、[26]、调试 [43]、[11]和实现[31]、[25]、[3]、[37]中很流行。因此，我们的逻辑规范本⾝可以被视为声明性程序：输⼊包括关于⽹络的事实（例如， 网络拓扑、VM配置等）或传⼊消息（例如，路由请求），⽽输出包括实际的⽹络状态（例如，最短路径、可到达的虚拟机对等）或传出消息（例如，路由更新）。</p>
<p>我们设想将NetSpec 应⽤于各种场合：</p>
<ol>
<li>通过将合成的逻辑规范编译成分布式实现，快速建立协议设计原型。</li>
<li>在设计时，通过提供输⼊-输出⽰例验证网络协议，这些示例是合成逻辑规范的基础。当验证者发现设计错误时，⽤⼾可以通过添加新⽰例来纠正设计。</li>
<li>在运行时，从执行过程中获取遗留程序(<em><strong>legacy program</strong></em>)并派生其逻辑规范。以进⾏后续验证或软件分析。当验证者找到反例时，它可以⽤来针对遗留程序进⾏测试。如果遗留程序表现出不良⾏为，就会发现真正的错误。否则，逻辑规范是不准确的，可以通过将反例添加到NetSpec中来进行优化。</li>
</ol>
<p>为了实现上述功能，NetSpec提供了一些关键特性，这些特性优于目前最先进的示例编程方法，并使其能够有效的应用与上述情景。我们下面阐述这些特点：<br>    1. <em><strong>表现⼒：</strong></em> NetSpec能够⽀持⽹络规范中涉及的复杂语义。这些功能包括递归、聚合和⽤⼾定义函数(UDFs)。现有的⽤于综合声明性程序技术都不⽀持这种功能组合，这使得它们⽆法满足许多常⻅的⽹络规范，例如路由协议和共识协议。<br>    2. <em><strong>可拓展性：</strong></em> NetSpec 使⽤⼀种新颖的最优先搜索算法，该算法从简单到复杂的程序逐步进⾏，并具有快速回溯的能⼒，从⽽能够有效地探索⽆限的搜索空间并⽣成简洁的规范。相⽐之下，现有技术要么要求⽤⼾限制搜索空间[24]、[33]（例如，通过提供最⼤数量的运算符），要么搜索大量错误程序导致效率低下[28]。<br>    3. <em><strong>鲁棒性：</strong></em> NetSpec 对输⼊-输出⽰例的质量具有鲁棒性。基于⽰例编程的⽅法依赖于⽤⼾制作⼀套完整的⽰例从而获得正确的程序。然⽽，⼿动提供这些⽰例时，很容易遗漏一些特殊情况。 NetSpec 主动检测并指定⽰例中的不完整性，并向⽰例提供者 （⽹络运营商或遗留实施）⽣成新的输⼊查询。这些新的输⼊与提供商的答案作为输出，提⾼了⽰例质量，并使 NetSpec 能够无歧义地合成正确的程序。</p>
<p>我们开发了 NetSpec 原型，并在⼀套 26 个基准测试中对其进⾏了评估，这些基准测试涵盖了不同领域中的各种⽹络协议， 包括⽹络分析、软件定义⽹络 (SDN)、传感器⽹络、路由协议和共识协议。我们的实验表明，NetSpec 可以在⼏秒钟内准确地地综合⼤多数逻辑规范，最复杂的规范稍微超过1分钟。 相⽐之下，最先进的⼯具 GenSynth [28] 和 Scythe [42] ⽆法合成需要聚合或⽤⼾定义函数的基准（26个中的10个），以及需要递归或⽤⼾定义函数的基准（26个中的11个)。此外，NetSpec综合的规范可以直接编译为声明式⽹络[31]、[25]，⽤于分布式实现。</p>
<p>为了在实际实现中验证NetSpec，我们进⼀步证明 NetSpec 能够从实际程序的执⾏记录中合成逻辑规范，这些程序执⾏记录是⽤ Floodlight [19] 和 POX [32] 编写的，来源于开源SDN控制器。这突出了NetSpec合成大规模程序规范的能力。 综上所述，本文的关键技术贡献如下：</p>
<ol>
<li>我们提出了一种新颖的合成算法，可以从输入-输出示例中高效地合成具有高表达能力的网络规范。这些规范，用⼀阶关系逻辑表示，具有验证、分析、生成实现等多种用途。</li>
<li>由于⽰例编程⽅法很容易遗漏示例，因此我们开发了⼀种新颖的⽰例⽣成算法来补充合成。它向示例提供者程序查询新⽰例，以指导合成算法得到无歧义的规范。</li>
<li>我们在 NetSpec ⼯具中实现我们的⽅法，并根据不同的基准和⽤例对其进⾏评估。NetSpec 能够在⼏秒钟内正确合成各种⽹络协议，并且对于丢失的示例具有鲁棒性。此外，我们证明 NetSpec 在表达能⼒和合成程序的质量⽅⾯优于最先进的合成⽅法。</li>
</ol>
<h2 id="二、用例介绍"><a href="#二、用例介绍" class="headerlink" title="二、用例介绍"></a>二、用例介绍</h2><p>在本节中，我们以<strong>最短路径路由协议</strong>为例来说明NetSpec 的端到端操作。NetSpec的整体架构如图 1 所⽰。在第 2.1、2.2 和 2.3 节中，我们分别描述了输⼊输出⽰例、综合算法和⽰例独自增强过程。<br><em><strong>图  1</strong></em><br><img src="/NetSpec-paper/image(1).png"></p>
<h3 id="2-1-问题描述"><a href="#2-1-问题描述" class="headerlink" title="2.1  问题描述"></a>2.1  问题描述</h3><p>NetSpec 采⽤两种输⼊：<br>    1. ⼀组输⼊输出⽰例对，其中每对由⼀组输⼊表和⼀组输出表组成。这些表是相关的，其中每⼀⾏被解释为 Datalog 中的关系元组。<br>    2. （可选）可能出现在输出规范中的⽤⼾定义函数和聚合器的列表。 NetSpec 返回⼀个与输入-输出示例一致的逻辑规范，该规范采⽤ Datalog 语法。在本⽂的其余部分，我们将交替使用规范(specification) 和程序(program)指代 NetSpec 的输出。</p>
<p>图(2a) 描述了最短路径路由协议的一个⽰例。在此⽰例中，提供了⼀个输⼊-输出对。输⼊表名为<strong>link</strong> ，将⽹络拓扑描述为加权图。输出表名为<strong>bestPath</strong> ，为每对源节点和⽬标节点指定最佳路径。函数包括列表初始化(<strong>list initialization</strong>)、（L&#x3D; [x，y]), 连接(<strong>concatenation</strong>) (X::L），以及成员检查（<strong>menbership checking</strong>）（X in L），还提供了聚合器（<strong>aggregators</strong>）（min and max）。</p>
<p><em><strong>图 (2a)</strong></em><br><img src="/NetSpec-paper/image(2a">.png alt&#x3D;”图(2a)”)</p>
<p><em><strong>图 (2b)</strong></em><br><img src="/NetSpec-paper/image(2b).png"></p>
<p>根据这些数据，NetSpec ⾃动合成的声明性逻辑规范如图(2b)所⽰。我们使⽤ Datalog 语法表达了规范，我们将在第 3 节中简要回顾⼀下。前两条规则指定节点对之间的路径及其成本：规则 r1 指定⽹络链路为⼀跳路径，规则 r2 指定传递情况。尤其，X::p1 表示前置节点X到路径p1的首部，!(X in p1) 检查X不在路径中p1,以避免⽣成循环并强制终⽌。规则 r3 和 r4 选择成本最⼩的路径作为最佳路径输出。</p>
<p>该规范提供了⽤于验证路由收敛属性[41]（route convergence properties）和解释路由派⽣[45]（explaining route derivations）的⾼级抽象。类似地，其他路由协议的逻辑规范也可以⽤于推理不同⽹络动态下的⽹络连接性[26]、[20]。</p>
<p>尽管最终规范很简单，但⼏个⽅⾯的综合问题使其在实践中具有挑战性。⾸先，搜索空间巨⼤。例如，规则 r2 包含 13 个变量，因此有13！≈109种情况，甚至是在其他规则结构的其余部分固定之下。此外，规则之间的相互作⽤使得问题不再具有组合性，并且使得⼀次合成⼀个规则的技术变得不适⽤[30]，[15]。 最后，由于输⼊-输出⽰例通常未充分指定⽬标概念，并且由于程序等价的不确定性[2]，因此很难确定综合规范是否正确捕获了⽤⼾的意图。</p>
<h3 id="2-2-优化合成"><a href="#2-2-优化合成" class="headerlink" title="2.2  优化合成"></a>2.2  优化合成</h3><p>我们将综合算法组织为⼀个优化问题，并在图3中说明了该过程。图中的每个节点代表⼀个候选程序，其传出边表⽰其每个可能的后代。我们重点介绍导致最终程序的关键步骤，算法的详细细节推迟到接下来的两节。</p>
<p>从概念上讲，我们考虑对每个候选程序进⾏三种可能的调整（modifications）：引⼊规则、在规则中引⼊⽂字以及引⼊聚合运算符。（introducing rules, introducing literals within a rule, and introducing aggregation operators.）在本节的其余部分中，我们⾸先描述应⽤调整的总体搜索策略，然后概述每一个调整步骤。</p>
<p><strong>搜索策略：</strong> 优化问题的⽬标函数基于<strong>候选程序s(condidate program s)</strong> 成功执行后返回的的两个衡量标准：</p>
<p>$$score(s) &#x3D; precision(s) \times\ recall(s)$$</p>
<p>尤其，给定⼀组预期输出元组$O_{exp}$，以及候选规范$s$ 产⽣⼀ 组输出元组$O_{ret}$，我们计算$precision(s)&#x3D;|O_{exp} \bigcap\ O_{ret}|&#x2F;|O_{ret}|$，这是预期⽣成的元组的分数，以及$recall(s) &#x3D; |O_{exp} \bigcap\ O_{ret}|&#x2F;|O_{exp}|$，这是候选规范⽣成的预期元组的分数。这$score(s)$按照$γ(s)$的衡量标准进行折算。</p>
<p>从得分为0的空程序开始，综合算法通过应⽤所有<strong>变异策略(mutation strategies)</strong> 重复⽣成后代程序，并将这些后代添加到候选程序集中。下⼀个要变异的程序是从具有较⾼分数的后代中采样的，如果没有后代具有更⾼分数时，从整个候选程序集合中采样。</p>
<p>图3中，输⼊关系表<strong>link</strong>在程序1和2中，⽣成 6 个预期<strong>bestPath</strong>元组中的 3 个最佳路径程序 。例如，规则***bestPath（x，y，p，c）：-link（x，y，c）， p&#x3D;[x,y]<em><strong>，recall值为0.5，precision值为0.75，在所有候选程序中得分最⾼。红⾊的bestPath元组表⽰从a到c的最短路径是不正确的，需要修正。此外，⼀些</strong>bestPath</em>*元组丢失。在随后的步骤中，根据路径的传递规则，得分最高的候选程序会被相继修改，根据聚合操作选择出最优权重路径。在后续步骤中，最终，纠正了红色元组，⽣成了缺失元组，并且我们收敛到与给定输⼊输出⽰例匹配的最佳路径。<br><em><strong>图 3</strong></em><br><img src="/NetSpec-paper/image(3).png"><br>接下来我们描述可以应⽤于当前最佳候选程序的三个调整步骤。通过引⽤图 3 中⽣成的候选程序 (1-4) 来描述每个调整步骤。</p>
<p><strong>调整1：引⼊新规则</strong> 该算法⾸先枚举产⽣一个规则程序，并生成至少一个目标输出元组。当中间程序⽆法产⽣所需的输出元组时，即它具有不完美的recall（⼩于1），此规则生成算法同样会被调用。选择每个合成规则，以便它⽣成⾄少⼀个当前缺失的目标元组。这些规则是通过向⼀组最⼩规则重复引⼊⽂字（修改 2） 来合成的，该组仅包含⼀个头⽂字和⼀个主体⽂字，直到它产⽣ ⾄少⼀个目标输出元组。</p>
<p>我们在图 3 中的运⾏⽰例中说明了这个过程。在两个细化步骤之后，运⾏最佳优先搜索算法的过程中，precision和最佳候选程序的recall分别为0.75和0.5。此时，最佳候选程序凭借以下条件只能生成一跳的最佳路径：***bestPath（x，y，p，c）：-link（x，y，c），p &#x3D; [x，y]***（Program 2）。需要添加新规则，以便可以为两跳及以上的路径⽣成输出，这是通过添加包含以下内容的递归规则来完成的， 且包括了bestPath规则。添加此新规则后，结果输出（程序 3）的recall增加到1，虽然精度还达不到1（等待⼀项额外的调整以引⼊聚合）。</p>
<p><strong>调整2：通过引⼊⽂字来细化规则</strong> 如果候选程序的精度⼩于1，算法会通过引⼊⽂字或通过聚合操作来增强其规则，从⽽为其规则添加新的约束。通过在其规则中添加新的⽂字，该算法产⽣了⼀个后代程序s′，它能够产⽣原始程序s产⽣的输出元组的⼦集。</p>
<p>为了提供有关规则细化的⼀些灵感，我们考虑图 3 中所⽰的场景，其中当前最佳候选者是部分规则（partial rule）<em><strong>bestPath（x，y，_， c）：-link（x，y，c）（Program 1）</strong></em>。由于尚未指定输出关系的第三列，因此算法仅通过将剩余列与参考输出进⾏⽐较来对该部分规则（partial rule）进⾏评分。直观上，部分规则（partial rule）错误地预测了（a,c）路径的成本，使程序的precision为 0.5，recall为0.75。score还额外折扣了⼀个系数γ&#x3D;0。75, 是为了解释输出的不完整性，并使规则搜索偏向于更快的规则完成。此时，规则细化添加了literal <em><strong>p&#x3D; [ x、y ]</strong></em> 其中 [ ] 是路径串联函数，它是提供给合成算法的候选⽤⼾定义函数之⼀。有趣的是，通过这种改进，虽然在结果输出（Program 2）的precision并未改变，$γ$增加到1并且所有列值都是已知的。</p>
<p>请注意，这种添加⽂字的过程为⽀持任意函数提供了灵活性，因为它不对底层语义做出任何假设。它也⾮常⾼效，因为它⼀次只考虑⼀个⽂字，⽽不是⽂字的任意组合。</p>
<p><strong>调整3：聚合运算符</strong> 修改程序输出的最后⼀种⽅法是应⽤聚合操作来⽣成一个输出序列。考虑规则r3，它找到x和y之间最短路径的长度。⾮正式地，聚合运算符min⾸先按源节点和⽬标节点对输出元组进⾏分组，(x,y), 然后汇总所有可能存在存在路径的值：<em><strong>path（x，y，_，c）</strong></em> 。在图3中，添加min之后，聚合到⼀个候选值（程序3），算法收敛到最终解决⽅案（程序 4）。</p>
<p><em><strong>图 4</strong></em><br><img src="/NetSpec-paper/image(12).png"></p>
<h3 id="2-3-增强过程示例"><a href="#2-3-增强过程示例" class="headerlink" title="2.3  增强过程示例"></a>2.3  增强过程示例</h3><p>综合算法发现与输⼊输出⽰例⼀致的所有程序达到了最⼤深度。当提供的输⼊输出⽰例仅部分约束可能的解决⽅案时，算法可能会发现多个解决⽅案，所有这些解决⽅案都与数据⼀致。我们在图 4 中展⽰了最短路径路由程序的两种可能的解决⽅案，并以⻩⾊突出显⽰了它们的差异。⼀般来说，在逐例编程（programming-by-example）（PBE）系统中，处理欠约束规范是一项重大挑战。同时，解决歧义的方案也是本文的重要贡献。</p>
<p>消除歧义困难的原因之⼀是Datalog程序的等价性检查问题是不可判定的[2]。为了解决这个问题，NetSpec 采⽤了程序分析 [27] 中的差异测试的思想，通过随机扰动的输⼊重复运⾏两个程序。在我们的⽰例中，通过修改链接成本，得到了可以揭⽰两个程序之间差异的输⼊。然后，我们可以要求⽤⼾提供这个新⽰例的基本事实（ground truth），这将反过来消除⾄少⼀个候选解决⽅案。重复该过 程，直到只剩下⼀个程序，在后⼀种情况下，NetSpec 会⽣成最简单的程序作为最终解决⽅案。因为枚举过程偏向于较⼩的程序，平局的情况偏向于语法最小的解决方案，在实际应用中，NetSpec生产的小程序也易于解释，且不易过度拟合。</p>
<h2 id="三、NeSpec规范语言"><a href="#三、NeSpec规范语言" class="headerlink" title="三、NeSpec规范语言"></a>三、NeSpec规范语言</h2><p>本节对由NetSpec所综合的规范语⾔进⾏了更正式的概述。该语⾔的设计有两个关键⽬标：表达各种⽹络规范的能⼒，以及利⽤各种⽹络验证器、分析器和实现的能⼒。</p>
<p>图5展⽰了规范的抽象语法。我们使⽤图2b所⽰的最短路径路由规范的运⾏⽰例来阐明它。规范是⼀个程序，其输⼊和输出是⼀组关系。在我们的路由⽰例中，输⼊关系包括link，它代表⽹络拓扑，以及常⻅谓词，例如in（list membership）。输出关系包括bestPath，它表⽰输⼊⽹络中每对节点之间的最短路径，以及诸如path和minCost等，这些保存计算bestPath所需的中间结果。</p>
<p>规范包含⼀组规则，指定如何根据输⼊关系计算输出关系。我们的路由⽰例包含四个规则，表⽰为r1 到r4。每条规则都是 ⼀个 Horn ⼦句，其形式为：<br>$$ R_{h}\ (\bar x_{h}) : -R_{1}(\bar x_{1}), …,R_{n}(\bar x_{n})$$<br>$\bar x_{i}$表示对应元素变量的向量组。<br>每条规则从右向左读，作为普遍量化的定义。对于变量$\bar x$，如果每个元组$R_{1}(\bar x_{1}),…,R_{n}(\bar x_{n})$都是被导出的，从而构成$R_{h}(\bar x_{h})$。</p>
<p>例如，规则r4在我们的路由⽰例中所表示的，如果$path(x,y,p,mc)$和$minCost(x,y,mc)$是可导的，从而可得$bestPath(x,y,p,mc)$。这条规则还描述了⼀个基本的逻辑运算：合取（conjunction）（即join）。另⼀⽅⾯，析取(disjunction)（即union）是通过具有相同头关系的不同规则来表达的，规则 r1和r2分别表示计算<strong>路径关系</strong>的基本情况和归纳步骤。这两条规则还说明了递归——⽹络规范中通常需要的⼀种操作，⽤于指定可达性属性。</p>
<p>到⽬前为⽌描述的功能可以用声明性逻辑编程语⾔ Datalog [2]进行描述。然⽽，Datalog 不⾜以表达具有现实世界丰富的⽹络规范。因此，NetSpec 的规范语⾔通过三种附加操作扩展了 Datalog：否定（表⽰为！）、聚合（例如，min和count），和⽤⼾自定义函数，其中包括常⻅的实⽤函数，例如：：（列表前置）和+（整数加法）。为了确保有良好基础的语义，（带有否定的数据记录程序应该分层[2，第 15 章]），NetSpec 仅将否定应⽤于输⼊关系或函数，例如规则2中的函数in。此外，为了保持综合任务易于处理，NetSpec 对每个规则应⽤以下语法限制：<br>    1. 每个规则最多含有两个表示相同关系的关键字。例如，一个规则h（x,w）:-p(x,y)，p(y,z)，p(z,w)将不能被NetSpec生成，因为他含有3个表示关系“P”的关键字。<br>    2. 一个非关键字最多只能包括2个约束变量。例如，关键字!p(a，b，c)不能被添加到规则之中，因为他包括3个约束变量（a，b，c）。但是关键字!p(a,b,_)可以被添加。<br>    3. 在每个程序中最多使用一次聚合操作。<br>    4. 聚合操作只能被应用在规则的头部。例如，将min应用在规则3中，生成了输入网络中节点对x和y之间所有路径的最小花费c。<br>    5. 一个用户自定义函数的结果只能在规则的头部使用，例如，规则r2中+运算的结果。</p>
<p>在评估中，我们发现这些语法限制对先前文献中的所有声明式规范都没有影响。但有两层聚合的 PAXOS 除外。在第 7.1 节中，我们展示了如何通过将复杂协议分解成独立模块来合成这种复杂协议。</p>
<p>规范是可执行程序：执行开始时所有输出关系初始化为空，然后通过重复评估规则，直到输出关系停止变化。上面定义的语法限制，使得无论规则以何种评估顺序执行都能确保结果的确定性。不过，需要注意的是，递归和用户自定义函数的存在和用户自定义函数可能会导致程序无法终止（例如，通过递归应用整数加法）。NetSpec因此支持一类极具表现力的规范。</p>
<p>由NetSpec 合成规范的一个重要优势是它们适用于各种网络任务。它们可以使用SDN验证器（如Vericon[5]和FlowLog [31]等）和路由验证器（如Batfish [20]和FSR[41]等）进行验证。也可使用 NOD [26]，Tiros[4]，EsSPAN[45] 等网络分析工具进行分析。最后，它们可以在Network Datalog [25]和FlowLog[31]被编译成分布式实现。</p>
<p><em><strong>图 5</strong></em><br><img src="/NetSpec-paper/image(4).png"></p>
<h2 id="四、合成算法"><a href="#四、合成算法" class="headerlink" title="四、合成算法"></a>四、合成算法</h2><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法 1"></a>算法 1</h4><p>$Synth(I,O,F)$ . 假设输入元组$I$，预期输出元组$O$，函数集$F$，产生所有的连续规范。<br>    1. 初始化solutions集，$S :&#x3D; \emptyset$ ，candidate programs集，$Q:&#x3D;{P_{0}}$，current program $P :&#x3D; P_{0}$，$P_{0}$是一个空程序。<br>    2. while $Q \neq \emptyset$, do：<br>        a. 根据 等式2 计算$P$的后代，记作： $Offspring(P) &#x3D; {P^{\prime}<em>{1},P^{\prime}</em>{2},…}$<br>        b. 更新solutions集合，并添加剩余的程序进行下一步枚举。<br>            $S:&#x3D;S\bigcup {P^{\prime}\in Offing(P)|score(P^{\prime})&#x3D;1}$<br>            $Q:&#x3D;(Q&#x2F;P)\bigcup{P^{\prime}\in Offspring(P)|score(P^{\prime})&gt;0}$<br>        c.  取新的程序进行探索：<br>            $HS:&#x3D;{P^{\prime}\in Offspring(P)|score(P^{\prime})&gt;score(P)}$<br>            $HR:&#x3D;{P^{\prime}\in Offspring(P)|recall(P^{\prime})&gt;recall(P)}$<br>            $$P:&#x3D;\left{<br>        \begin{array}{rcl}<br>        Sample(HS,P)&amp;  &amp;{if\ \ HS\neq \emptyset}\<br>        Sample(HR,P)&amp;  &amp;{else\ \ if\ \ HR\neq \emptyset}\<br>        Sample(Q,P) &amp;  &amp;{otherwise}<br>        \end{array} \right.<br>        $$<br>    3. Return S.<br>    等式(2)如下所示：<br>    $$Offspring(P)&#x3D;O_{D}(P)\cup O_{C}(P) \cup O_{A}(P)$$，<br>    $$<br>    O_{D}(P)&#x3D;\left {<br>    \begin{array}<br>    AddRule(P)&amp;  &amp;{if \ \ recall(P)&lt;1,and}\<br>    \emptyset&amp;  &amp;{otherwise,}<br>    \end{array} \right.<br>    $$<br>    $$<br>    O_{C}(P)&#x3D;\left {<br>    \begin{array}<br>    ExtRule(P)&amp;  &amp;{if \ \ precision(P)\leqslant 1,and}\<br>    \emptyset&amp;  &amp;{otherwise,and}<br>    \end{array} \right.<br>    $$<br>$$<br>O_{A}(P)&#x3D;\left {<br>\begin{array}<br>MkAgg(P)&amp; &amp;{if\ \ precision(P)\leqslant1\ \ and}\<br>\emptyset &amp; &amp;{otherwise}<br>\end{array} \right.<br>$$</p>
<p>我们在算法1中介绍了顶层合成程序。仅需要输入元组$I$，和输出元组$O$，我们将在4.4节中介绍如何支持输入输出示例对的多个实例。正如第二节所述，它模拟了Datalog程序空间的优化问题，其中每个状态都是一个程序。目标函数$score(p)$被定义为$precision(p)$和$recall(p)$的乘积。</p>
<p>在每次迭代中，算法都会通过改变当前程序P，去探索程序空间。从而生成了多个子程序。</p>
<p>$Offspring(P)$的定义如公式2所示，其中$D$、$C$和$A$下标分别表示通过添加新规则(disjunctions),拓展现有规则(conjunctions),及应用聚合运算(apply)生成子代。应用变异策略(mutation strategy)的条件基于Datalog的语义。在连接规则(conjunction rule)中添加子句，并且聚合当前程序的输出，单调减少了程序输出集的大小(number of tuples),因此可能会提升precision，但是同时可能会降低recall。因此只有在程序不完全精确时才使用。相反的，添加规则单调增加程序输出集的大小，可能会提升recall，但同时降低precision。此外，我们假设程序空间中只使用一个聚合器，因此我们要等到所有必要的规则都添加完毕，以达到完全召回的效果，然后再应用聚合。</p>
<p>在step2b中，score为1的后代被添加到解集S中。Scoe为0的后代意味着它不会产生预期输出($P(I)\cap O&#x3D;\emptyset$)。这样的后代将被删除。根据前面的观察，对程序应用 ExtRule或 MkAgg 会单调地减少程序的输出大小。这意味着除了增加新规则，进一步扩展该程序的任何规则都不会产生任何想要的结果。此外，我们假设在所有求解程序中，每一条非聚合规则都直接得到输出元组($O$)中的某些输出。因此只有$score$不为零的规则($P(I)\cap O \neq \emptyset$)才会被添加到候选程序集($Q$)中，以便进一步突变。</p>
<h4 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h4><p>$Sample(Q,P)$. 假设candidate programs集为$Q$，current program集为$P$，返回程序集$P^{\prime} \in Q$.<br>For $k \in {1,2,…,K_{max}}$,do：</p>
<ol>
<li>从结合$Q$中均匀地程序$P^{\prime}$</li>
<li>计算$P^{\prime}$的接受概率：<br> $$s0 :&#x3D;score(P),s1:&#x3D;score(P^{\prime})$$<br> $$T:&#x3D;1-\frac{k}{K_{max}}$$<br> $$<br> Pr[accept\ \ P^{\prime}]:&#x3D;\left {<br> \begin{array}<br> 1&amp; &amp;{if\ \ s_{1}&gt;s_{0}}\<br> exp(-\frac{s0-s1}{T})&amp; &amp;{otherwise}<br> \end{array} \right.<br> $$</li>
<li>如果$Pr[accept P^{\prime}]\geqslant random(0,1):$ return $P^{\prime}$</li>
</ol>
<p>在step 2c中，下一个要探索的程序将以概率方式进行采样，当后代中存在更高$score$值，或者更高$recall$值的后代程序时，这些子代程序总是会被选为下一个要探索的程序。否则，它将从整个candidate programs $Q$ 中进行采样。子程序$Sample(Q, P)$ 在算法 2 中进行了描述。借鉴模拟退火的思想，均匀地取出候选程序$P^{\prime} \in Q$，并根据等式 3 计算的概率判断是否接受。直观地说，当候选程序的得分高于当前程序时，它被接受的概率为 1。否则，它被接受的概率为在 0 到 1 之间，取决于它的得分与当前程序相比有多差。</p>
<p>本节其余部分将逐一介绍这些突变策略以及合成算法的形式属性。</p>
<h3 id="4-1-添加和拓展规则"><a href="#4-1-添加和拓展规则" class="headerlink" title="4.1 添加和拓展规则"></a>4.1 添加和拓展规则</h3><p>$AddRule(P)$过程，枚举了所有最小规则，并通过向$P$中添加一条最小规则从而生成子代。最小规则是指主体中只有一个<strong>literal</strong>的规则，且头部只有一个字段与主体绑定，剩余字段都是空占位符。<br>在最短路径示例中，一个最小规则为：<br>$$r_0 :bestPath(x,_ ,_,_):- link(x,_,<em>_)$$<br>设$MinimalRules$为从输入和输出关系中获得的所有最小规则的集合，则 AddRule(P) 定义如下：<br>$$AddRule(P):&#x3D;{(P\cup r)|r\in MinimalRules}$$<br>接下来，我们引入 $ExtRule(P)$ 过程，它包含了对规则的两个原子操作，即$AddLiteral(r)$和 $AddBinding(r)$。它们的定义如下：<br>$$AddLiteral(r)&#x3D;{r\wedge l|r\in P,l\in L}$$<br>其中 $L$是$literals$的集合，这些$literals$的关系来自于所有输入关系、输出关系和用户定义函数的集合，并且只包含空占位符。$r\wedge l$表示一条新规则，表示在 $r$的主体中加入$literal\ \ l$。继续以$shortest-path\ \ routing$为例，$AddLiteral(r</em>{0})$生成的新规则之一是：<br>$$r_{1}:bestPath(x,_,_,_):-\ \ link(x,_,_,),besstPath(_,_,_,_)$$<br>$bestPath(_,_,_,_)$是输出关系$bestPath$的实例化。<br>接下来，$AddBinding(r)$定义如下：<br>$$AddBing(r)&#x3D;{r\wedge(v_{1}&#x3D;v_{2})|v_{1},v_{2} \in r \wedge dom(v_{1})&#x3D;dom(v_{2})}$$<br>$v_{1},v_{2} \in r$表示变量 v1 和 v2 出现在规则 $r$ 中，$dom(v)$ 是变量 $v$  的域，在出现 v 的字面模式中指定。<br>是变量 v 的域，在 $v$ 出现的字面意义模式中定义。举例说明的话：可以展示由 $AddBinding(r1)$生成的一个规则：<br>$$r_2:bestPath(x,_<em>,_</em>,_ )\ \ :- link(x,z,_),bestPath(z,_<em>,_</em>,_)$$<br>其中$literal\ \ link$ 中的第二个变量与$literal\ \ bestPath$ 中的第一个变量绑定。请注意，我们并没有明确像下面这条规则一样添加匹配两个变量的谓词：<br>$$bestPath(x,_<em>,_</em> ,_ ) ：-link(x,v1,)，bestPath(v2,__ ,__ ,_ ), v1 &#x3D; v2$$<br>为简洁起见，我们将 $v1$ 和 $v2$ 重命名为 $z$。<br>将它们放在一起，$ExtRule(P)$ 通过将 $AddLiteral$ 或 $AddBinding$ 应用到程序 $P$ 中的任意一条规则后，就能生成所有程序 。$ExtRule(P)$ 定义如下：<br>$$ExtRule(P)&#x3D;{(P&#x2F;r)\cup r^{\prime}|r \in P,r^{\prime} \in (AddLiteral(r) \cup AddBinding(r))}$$<br><em><strong>表 1</strong></em><br><img src="/%E7%BD%91%E7%BB%9C%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98/image(5).png"></p>
<p>表中表示部分程序 $P_{r}$ 的评分示例。它包含一条部分规则(partial rule) $r$，其中只确定了头部的两个字段，因此该规则只生成两列。精确度$(precision)$为 0.86，因为 7 个输出元组中有 6 个是所必需的。(in $O \cup \pi_{c}(O)$)。召回(recall)由两部分组成，即完整元组（绿色框中的 3 个）和部分元组（红色框中的 3 个）。部分生成的输出的召回率(Recall)降低了 0.5 倍，因为 4 列中只有 2 列生成。将他们放在一起，召回率总计为0.75。</p>
<h3 id="4-2-部分程序的评价"><a href="#4-2-部分程序的评价" class="headerlink" title="4.2 部分程序的评价"></a>4.2 部分程序的评价</h3><p>当应用 $AddRule(P)$ 和 $ExtRule(P)$ 时，我们将在程序队列中产生部分规则($partial\ \ rules$)。我们所说的部分规则是指在头部有空占位符的规则。我们进一步将部分程序定义为至少包含一条部分规则的程序。例如，考虑关系 $bestPath(x,y,p,c)$ ,一个部分规则如下所示：<br>$$r_{p1}:bestPath(x,y,_<em>,_):-link(x,z,_),bestPath(x,y,_,_)$$<br>请注意，这条规则只产生输出关系的前两列，即源节点和目的地节点。但不会产生其余两列，即最优路径及其长度。因此，带有这些部分规则的程序，例如 $P\cup {r</em>{p1}}$，无法直接与整个参考输出  $O$ 进行比较。借用关系代数中的投影符号，我们只能将其前两列与 $\pi_{src,dest}(O)$ 进行比较。由此，我们可以得出部分程序 $P_{r}$ 的精确度(precision)和召回率(recall)定义如下：<br>$$precision_{d}(P_{r})&#x3D;\frac{|P_{r}(I)\cap(O\cup\pi_c(O)|}{|P(I)|},O^{\prime}&#x3D;{t\in(O&#x2F;P(I))|\pi_c(t)\in P(I)}$$<br>$$recall_d(P_{r})&#x3D;\frac{|P(I)\cap O|+\gamma |O^{\prime}|}{|O|}$$<br>其中，$\pi_c$是投影算子，投影到已经和部分规则头部绑定的列。集合 $O^{\prime}$ 是 $O$ 的子集，但不在 $P(I)$中，但其在列 $c$ 上的投影出现在 $P(I)$中。我们在上图中直观地展示了这个集合的计算过程。</p>
<h3 id="4-3-聚合操作的介绍"><a href="#4-3-聚合操作的介绍" class="headerlink" title="4.3 聚合操作的介绍"></a>4.3 聚合操作的介绍</h3><h4 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h4><p>$MkAgg(P)$. 通过引入聚合算子产生 $P$ 的子代。</p>
<ol>
<li>设置 $F$ 是聚合操作族，让$C$ 是输出关系 $R$ 中所有列的集合。</li>
<li>对于每个算子 $op∈F$, 每个子集 $C_{agg} ⊆C$，对于每个聚合列 $f ∈ C&#x2F; C{agg}$ ，构建子程序 $P^{\prime}$：首先将 $P$ 的输出关系 $R$ 重命名为 $R_{base}$，设 $C_{rem}$ 为remaining columns $C &#x2F; C_{agg} &#x2F; {f}$。然后添加以下两条规则。<br> $$R_{opt}(C_{agg},f_{opt}):-R_{base}(C_{agg},f_{opt},_),f_{opt}&#x3D;op\ \ f:R_{base}(C_{agg},f,_).$$<br> $$R(C_{agg},f_{opt},C_{rem}):-R_{opt}(C_{agg},f_{opt}),R_{base}(C_{agg},f_{opt},C_{rem}).$$</li>
<li>返回在step2中生成的所有子代集合。</li>
</ol>
<p>算法 3 描述了 MkAgg 程序。回想一下 图3 运行示例中的第三个程序：<br>$$r1: bestPath(x, y, p, c) :- link(x, y, c), p &#x3D; [x, y].$$<br>$$r2: bestPath(x, y, x::p, c1 + c2) :-\ \ link(x, z, c1), bestPath(x, y, p, c2), !(x \ \ in \ \ p1)$$<br>该程序能正确预测可达性关系，但却产生了额外的错误路径，也就是说，它的召回率是完美的，但精度却不完美。在这种情况下，NetSpec 尝试通过引入聚合运算符来纠正这种情况。它引入了两条新规则，可以非正式地解释如下 ：第一条规则选择列的子集（在本例中，源节点 x 和目标节点 y ）,并对另一列执行聚合操作(在本例中，计算所有路径权重的最小值)。第二条规则会选择其余列的值，这些列的值会导致最大化或最小化目标的实现。因此，经过变异后，下面的程序将被添加到队列中：<br>$$r1: path(x, y, p, c) :- link(x, y, c), p &#x3D; [x, y].$$<br>$$r2: path(x, y, x::p, c1 + c2) :- link(x, z, c1), bestPath(x, y, p, c2), !(x\ \ in \ \ p1).$$<br>$$r3: minPath(x, y, mc) :- path(x, y, _, mc), mc &#x3D; min c: path(x, y, _, c).$$<br>$$r4: bestPath(x, y, p, mc) :- minPath(x, y, mc), path(x, y, p, mc).$$</p>
<h3 id="4-4-支持多个输入输出示例对"><a href="#4-4-支持多个输入输出示例对" class="headerlink" title="4.4 支持多个输入输出示例对"></a>4.4 支持多个输入输出示例对</h3><p>到目前为止，我们的算法描述是基于一个输入元组( $I$ )，一个输出元组 ( $O$ )。为了支持具有的多个实例的情况，NetSpec 为每个元组引入了一个额外的字段 $InstanceID$。表明了元组所属的特定示例。不同实例的元组会合并成一组输入图元( $I$ )和一组输出图元( $O$ )。在规则搜索过程中，NetSpec<br>生成将所有 “InstanceID “字段绑定到一个变量的规则。例如，NetSpec 生成的规则如下：<br>$$h(v1,v2,i) :-\ \  p1(v1,v3,i), p2(v3,v2,i).$$<br>其中 $InstanceID$ 字段的所有变量都绑定到相同的名称$i$ 。因此，有多个实例的综合问题被简化为有单一实例的综合问题，可通过算法1解决。</p>
<h3 id="4-5-合理性和完整性"><a href="#4-5-合理性和完整性" class="headerlink" title="4.5 合理性和完整性"></a>4.5 合理性和完整性</h3><p><strong>定理 1(合理性)</strong> 给定一个输入元组和一个输出元组( $I$,$O$ )， 当 NetSpec 终止时，其输出 $S$ 满足以下属性：<br>$$∀p ∈ S, p(I) &#x3D; O$$<br><strong>证明：</strong> 在算法 1 中，当且仅当 $score(p) &#x3D; 1$ 时，程序 $p$ 才会被添加到解集 S 中（step 2b）。要证明<br>定理 1 只需证明：<br>$$score(p) &#x3D; 1 ⇒ p(I) &#x3D; O$$<br>其中 $score(p)$ 的定义见公式 1。根据定义，当 $score(p) &#x3D; 1$ 时，程序输出 $p(I)$ 在参考输出 $O$ 上具有完美的精确度和召回率。这说明 $p(I) &#x3D; O$</p>
<p>接下来，我们说明完备性属性。我们首先定义程序空间($program\ \ space$)如下：<br><strong>定义 1（$Empty \ \ program$）</strong> 当且仅当程序 p 不包含任何规则时，它是空程序。<br><strong>定义 2（$Succcessor \ \ relation$）</strong> 设 $→$ 是 Datalog 程序集上的二元关系表示：<br>$$p → q ⇐⇒ q ∈ Offspring(p)$$<br>让 $→^{∗}$是 Datalog 程序集上的二元关系表示为：<br>$$p →^∗ q ⇐⇒ p → p_1 → … → p_n → q$$<br>当 $n \geqslant 0$ 时。<br><strong>定义 3（$Output-contributing \ \ rule$）</strong> 给定一组输入元组和一组输出元组 (I,O)，程序 p 中的规则 r的评估结果与 O 相交。</p>
<p>一种特殊情况是，程序中存在聚合操作（$argMax$ 或 $argMin$）。如果 $r$ 的输出被聚合，那么 $r$ 的<br>的结果与 $O$ 中重命名的元组进行比较，后者的关系被重命名为 $r$ 的输出关系。在最短路径示例中（图 2b），$path$关系被聚合为 $bestPath$，在判断 $r1$ 是否对输出有贡献时，我们将 $O$ 中的关系元组由 $bestPath$ 重命名为$Path$，然后检查交集( $intersection$ )。如果 r 是聚合规则，因为 NetSpec 同时引入了聚合规则（$min$ 或 $max$）和选择规则，以实现$argMin$ 或 $argMax$ 语义，因此 r 的输出被解释为聚合规则和选择规则的推导结果。在最短路径示例中，$r3$ 和 $r4$ 是同时引入的，如果 $r4$ 的推导结果与 $O$ 相交，它们都被视为输出贡献规则($Output-contributing \ \ rule$)。NetSpec 的所有解决方案都只包含输出贡献规则，因为在算法 1 的规则扩展阶段，如果新扩展的规则不能产生预期输出，候选程序就会被放弃。</p>
<p><strong>定义 4（$Program \ \ space$）</strong>。给定一组输入元组和一组输出元组 $(I,O)$，以及一组用户定义的函数、<br>设$P_c$ 为只包含输出贡献规则($Output-contributing \ \ rule$)的 Datalog 程序集（定义 3）。程序空间定义为$P_c$ 中空程序 $p_0$ 的后代程序。<br>$${p ∈ P_c| p_0→^∗ p}$$<br><strong>定理 2（$Weak \ \  completeness$）</strong>。对于所有输入输出表$(I,O)$，如果在程序空间（定义 4）中存在一个程序 $p$，输入为$I$ 时，程序$p$可以在时间 $T$ 内终止并得到输出 $O$ ，那么 NetSpec 总会返回一个解集 $S$，至少包含一个这样的程序 $P$ ，否则，它将返回一个空解集 $S &#x3D; ∅$。</p>
<p>这一完备性属性是 $weak$ 的，因为它假定的程序空间（只有导出输出元组的规则，定义 4）比完整程序空间小。${p|p_0→^∗ p}$。例如，在图 2b 的路由协议中，规则 $r1$ 生成单跳路径。给定一个输入网络，所有最佳路径都有一跳以上，那么 $r1$ 的输出与所需输出没有交集，因此会被算法丢弃。附录 A 展示了定理 2。</p>
<h2 id="五、处理不完整示例"><a href="#五、处理不完整示例" class="headerlink" title="五、处理不完整示例"></a>五、处理不完整示例</h2><p>现在，我们将介绍示例扩增过程。给定一个初始输入输出示例集，当找到多个符合要求的程序时，NetSpec 会搜索新的输入示例，以区分这些候选程序，并要求用户为这个新输入示例指定预期输出。通过主动询问用户的反馈意见，使得系统就能稳健地学习程序，即使是在一组初始指定不足的示例。</p>
<h3 id="算法4"><a href="#算法4" class="headerlink" title="算法4"></a>算法4</h3><p>$Sample()$. 采样新的输入元组消除歧义。</p>
<ol>
<li>初始化输入元组$I:&#x3D;\emptyset$</li>
<li>For each input relation $R$：<br> a. 均匀采样元组的数量，$n∈{1, 2, . . . ，n_{max}}$，其中 $n_{max}$ 是采样表的上限。<br> b. 抽取 n 个元组 $t_1、t_2、…… , t_n，$其中每个 $t_i$ &#x3D; $(c_1，c_2，…，c_k)$，所有常数都是均匀采样的，其中 $k$ 是关系 $R$ 的复杂性。<br> c. 将$t_1,t_2,…,t_n$ 插入$I_R$</li>
<li>返回 $I$</li>
</ol>
<p>我们在算法 4 中描述了核心示例的采样过程。其中，在$step \ \  2a)$ 中，$n_{max}$ 是初始示例输入 $I$ 中表大小的最大值。在$step \ \ 2b)$中，从所有出现在初始输入 $I$ 中的常量集合中均匀采样。给定一组候选程序 $P_1,P_2,… , P_n$，与初始示例输入 $I$ 上是一致的（即$P_{1}(I)、P_{2}(I)、…、P_{n}(I)$ 与初始示例输出相匹配），我们重复运行采样程序，以获得 $k$ 个新的示例输入 $I_1、I_2、… , I_k$。然后，我们选择一个输入示例$Iq ∈ {I_1, I_2, …, I_k}$，让用户为相应的示例输出贴标签，如下所示：<br>$$Iq &#x3D; arg_{I_{j}}max(− \sum_O P_O log(p_O)),$$<br>其中，$O$ 的范围是示例输出集合${ P_1 (I_j )，P_2(I_j )，…，P_n(I_j ) }$，而 $p_O$ 是生成输出集合 $O$ 的候选程序的分数。通过最大限度地提高新示例的熵，我们可以在用户反馈后尽可能多地淘汰程序。我们使用 n &#x3D; 4 个候选程序和 k &#x3D; 3 个示例 ${I_1,I_2,I_3}$ 进行解释：</p>
<ol>
<li>这些程序在 $I_1$ 上是一致的。那么，$O$ 的范围是单个输出集合，$p_O &#x3D; 1$，所以$I_1$的得分为$-(1 \cdot 1 \cdot log(1) &#x3D; 0)$。</li>
<li>在 $I_2$ 中，这些程序各占一半。那么，$O$ 的范围是一组两个不同的输出，$p_O &#x3D; 0.5$，因此 $I_2$ 的得分是$-(2 \cdot 0.5 \cdot log(0.5)) ∼ 0.69$。</li>
<li>每个程序都会在 $I_3$ 上产生一个唯一的输出。那么，$O$ 的范围是一组四个不同的输出，$p_O &#x3D; 0.25$，因此 $I_3$ 的得分是 $-(4 \cdot 0.25 \cdot log(0.25)) ∼ 1.38$。</li>
</ol>
<p>因此，$I_3$ 将被选为新的示例，这与用户反馈的直觉是一致的，即淘汰最多的候选程序（ 4 个中的 3 个）。<br>我们重复这一过程，直到剩余的程序不再能通过采样输入进行区分。这种方法类似于$query-by-committee\  \ method$，使得 NetSpec 能够快速收敛到最终解决方案。</p>
<p><strong>定理 3</strong>. 假设 NetSpec 总是能够消除候选程序的歧义，并且用户总是能向NetSpec的询问提供正确答案，如果程序空间中存在解 $p$（定义 4），在主动学习之后，NetSpec 总会返回在逻辑上与 $p$ 等价的解。<br><strong>证明：</strong> 根据定理 2，每次迭代合成后，$p$ 总是在解集 $S$ 中。假设NetSpec 总是能够区分候选程序<br>的假设，总是会产生一个新的查询，将 $p$ 与其他解决方案区分开来，直到 $S$ 中的所有程序在逻辑上都是等价的。因此，当 NetSpec 终止时，所有解决方案在逻辑上都等价于 $p$。</p>
<h2 id="六、执行情况"><a href="#六、执行情况" class="headerlink" title="六、执行情况"></a>六、执行情况</h2><p>NetSpec 由 Scala 实现，包含 3.5K行代码。它使用 Souffle [38] 作为后端 Datalog 解释器来验证候选规范。本节中，我们将讨论有关NetSpec 如何处理非终止候选规范，以及如何合成带有常量的规范的实现细节。<br><strong>处理非终止规范($non-terminating \ \ specifications$)</strong> 在综合过程中，由于存在递归和用户自定义函数，NetSpec 可能会遇到非终止规范。例如，第 2.1 节中综合路由示例时，NetSpec 会遇到以下候选对象：<br>$$r1: path(x,y,p,c) :-\ \ link(x,y,c), \ \ p&#x3D;[x,y].$$<br>$$r2: path(x,y,x::p1,c1+c2) :-\ \ link(x,z,c1),\ \ path(z,y,p1,c2).$$<br><img src="/NetSpec-paper/image(6).png"></p>
<p><em><strong>表 2</strong></em>  合成结果足够满足原始示例的基准。在“<strong>Features</strong> ”栏中突出显示了使用递归、聚合和 UDF 特性的规范。“**#Relations<strong>”显示了每个规范的输入和输出关系的数量。指定示例的工作量由输入输出实例的数量和所有实例的行总数所描述。“</strong>Time**”列显示了每个工具的合成时间，单位为秒。”<strong>Output size</strong>“列显示每个工具的输出大小，以 Datalog规则的行数表示。合成时间和输出大小均为运行 10 次的平均值。NS.、Fa.和 GS.分别代表 NetSpec、Facon 和 GenSynth。在 “Time”一栏中，”×”表示工具终止且未找到解决方案，”TO”表示工具在 20 分钟后超时。对于工具不适用的基准，时间和大小项置为空。</p>
<p><img src="/NetSpec-paper/image(7).png"><br><em><strong>表 3</strong></em>  需要增加示例的基准是主动学习结果。NetSpec 运行主动学习(<em><strong>active learning</strong></em>)功能从而增强输入输出示例，并找到经过验证的解决方案。在 “<strong>#Queries</strong>“栏中，”<strong>med.</strong>“和 “<strong>max</strong>“分别代表中位数和最大值。”<strong>Time</strong>“列显示端到端平均时间。”<strong>TO</strong>“表示 1 小时后计时结束。”<strong>Output size</strong>“列显示合成规范的大小，以 Datalog 规则的数量来衡量。</p>
<p><em><strong>在规范中生成常数</strong></em>  许多网络规范都需要常量。例如在 SDN 防火墙规范中，控制器应用程序只监控和响应某个特定端口。如果不使用常量，就无法合成这样的规范。另一方面，如果天真地将常量添加到会导致与所提供的输入输出示例过度拟合。<br>为了区分那些需要常量的规范和那些可以通过符号实现的规范，NetSpec采用了一种故障切换机制：它只搜索符号规范即可启动；当它用完候选程序队列而又找不到解决方案时，它就会转而使用来自输入输出示例的常量。在 NetSpec 从执行轨迹中学习规范的实验中（第 7.3 节），所有防火墙应用程序都会监控专用交换机上的特定端口。根据它们的轨迹会触发故障切换机制，NetSpec 会根据交换机和端口9字段的常量合成规范。</p>
<h2 id="七、评价"><a href="#七、评价" class="headerlink" title="七、评价"></a>七、评价</h2><p>我们的评估旨在回答以下四个问题：</p>
<ol>
<li><em><strong>表达能力(Expressivity)</strong></em> . NetSpec 是否能正确合成各种网络规范，覆盖范围与最先进的综合工具相比如何？</li>
<li><em><strong>效率(Efficiency)</strong></em> . NetSpec 能否在合理的时间内（大约几秒）合成网络规范？</li>
<li><em><strong>鲁棒性(Robustness)</strong></em> . NetSpec 对输入输出示例质量是否稳健，尤其是能否处理不完整的示例？</li>
<li><em><strong>可扩展性(Scalability)</strong></em> . NetSpec 能否从来自大量执行路径的示例中学习规范，请注意，这个问题不仅涉及性能，还包括NetSpec对传统应用程序的脱机能力。</li>
</ol>
<p><em><strong>标准(Benchmarks)</strong></em> 我们调查了文献中声明式规范的使用情况，并将其分为五类：网络分析、SDN、传感器网络、共识协议和路由协议。网络分析是指事先在网络中形式化可达性和其他正确性的工作。[4]、[26]、[31]。SDN 规范来自验证控制器程序正确性的工作 [5]、[31]。传感器网络规范基于<br>声明式传感器网络系统 [14]。共识协议[3]和分布式路由基于针对分布式执行[25],[14],和验证[20],[17],[41]的声明式规范 。</p>
<p><em><strong>输入输出示例生成</strong></em>(<em><strong>Input-Output example generation</strong></em>) 为了提供不偏向任何合成器的示例，我们手动阅读了每个基准协议的文档，提出的输入输出示例能够涵盖文档描述的所有使用场景。示例大小<br>用输入输出示例（即输入输出表组）的数量来衡量，以及所有关系表中的元组总数（即关系表中的行数），如表 2 中 “<strong>#Examples</strong>“一栏所示。</p>
<p><em><strong>结果验证(Result validation)</strong></em> 如果经过以下两处修改后，合成结果与参考规范完全相同，那么合成结果就是正确的：(1)变量重命名， (2) 删除多余的谓词和规则（如果有的话）。我们手动验证了所有实验结果，参考文献 [1] 说明了如何验证每个基准，并提供了所有实验的综合结果。修改 (1) 在验证过程中占主导地位，少数结果需要修改 (2)。在本节其余部分我们将这些结果称为$validated \ \ solutions$。</p>
<p>本节其余部分的结构如下。在第 7.1 节中，我们通过与最先进的程序综合工具比较，评估了 NetSpec 的表达能力和效率。在第 7.2 节中，我们将评估 NetSpec 对输入输出示例质量的鲁棒性，在示例不足的基准上进行评价。在第 7.3 节中，我们将评估 NetSpec 的可扩展性。</p>
<h3 id="7-1-合成表达能力和效率"><a href="#7-1-合成表达能力和效率" class="headerlink" title="7.1 合成表达能力和效率"></a>7.1 合成表达能力和效率</h3><p>我们首先在有足够实例的情况下评估表达能力和合成效率。我们将 NetSpec 与两个最先进的工具 Facon [13] 和 GenSynth [28] 进行了比较。</p>
<p><em><strong>适用基准(Appplicable benchmarks)</strong></em> 与 NetSpec 一样，Facon 和GenSynth 都在关系输入-输出数据上运行。但是这两种工具都不支持 UDF 和聚合，表达能力较弱。因此，我们只在它们适用的基准上运行这些工具。此外，一些原始基准规范可能没有足够的实例。即发生缺省的情况从而导致规范错误。为了评估合成效率，并与不增强示例的基线进行比较，本节将重点关注为本实验提供足够实例的基准（表 2）。其中 NetSpec 在 10 次重复运行中至少有 8 次返回了有效解决方案。我们将在第 7.2 节中用不充分的例子重新讨论此应用。<br>此外，GenSynth 不支持多个实例。因此，我们将多个实例合并成一个实例，即属于同一关系的元组合并到同一个表中。我们通过对常数进行适当重命名，避免在原始实例中引入虚假的相关性。请注意由于某些常量（如端口号）是全局性的，因此不能重命名。这凸显了在 NetSpec 中能够支持多个<br>实例和常量的优点。</p>
<p><em><strong>性能指标(Performance metric)</strong></em> 我们根据不同领域网络规范包括：网络分析、SDN、传感器网络、共识协议和路由协议的覆盖范围来衡量 NetSpec 的表达能力。为了评估综合效率，我们在具有32 个 2.6GHz 内核和 125GB 内存的服务器上测量了端到端的合成时间，NetSpec 和 Facon 均以单线程运行。然而，由于其高度的非确定性，GenSynth 经常在单线程中无限期地运行。因此，我们在 8 线程模式下运行 GenSynth，以便在 20 分钟内获得结果。</p>
<p><em><strong>结果(Results)</strong></em> 表 2 总结了我们的总体结果。重点关注前两个表达能力和效率指标，主要启示如下：</p>
<p><em><strong>表达能力(Expressivity)</strong></em> NetSpec成功合成了表 2 中的全部 23 个基准，涵盖了不同类型的网络协议。<br>另一方面，由于语言特点支持，Facon [13] 和 GenSynth [28] 等解决方案仅支持 9 个基准。此外，<br>Facon 无法合成定位基准，因为它在 Facon 的程序搜索空间之外，该空间只包含 Datalog 规则，其中每个关系式最多出现一次。由于缺乏对否定的支持，Facon 和 GenSynth 都无法合成 $learningingswitch$ 基准。</p>
<p><em><strong>效率(Efficiency)</strong></em> NetSpec 非常高效。可在一分钟内完成大多数基准，但路径成本和 RIP 协议除外，分别需要 92 秒和 3 分钟。另一方面，Facon 只能合成 10 个基准中的 8 个，事实上，有两个基准在 超过了20分钟，看作超时。与 GenSynth 相比，NetSpec 在所有适用的基准测试中始终完成得更快。除了 reachable 和 sshT unnel 外，NetSpec 分别多花了 6 秒和 3 秒。这令人印象深刻，因为 NetSpec 在单线程中运行，而 GenSynth 在 8 线程运行。</p>
<p><em><strong>基于组件的合成的优点(Benefits of component-based synthesis)</strong></em> 我们的基准还展示了基于组件的合成方式的优点。我们描述了基于两种协议的案例研究： <strong><em>PAXOS(表 2 中为 paxos-</em>)</strong>* 和 <strong><em>DSR(表 2 中为 dsr-</em>)</strong>* 。<em><strong>PAXOS</strong></em> 的原始规范包含两层聚合(第一层为计算选票以确定哪张选票达到法定人数，然后通过选择票值最大的那一个)。在正常情况下，这超出了 NetSpec 的搜索能力，因为它最多只能合成一层聚合的程序。然而，将 <em><strong>PAXOS</strong></em> 分解成不同的组件，不仅可以进行合成，而且可以高效地进行。<br>另一方面，DSR 可以合成为一个整体协议。然而，通过将其合成分解为组件模块，大大减少了合成协议所需示例的数量。DSR 可独立处理三种不同的输入信息，因此有机会将合成任务分解为独立的<br>模块。例如，在合成处理路由请求信息的规则时，合成器无需考虑错误的路由信息。另一方面，如果将所有类型的信息组合在一起，由于存在更大的程序空间，虽然 NetSpec 仍能高效地处理，但它会生成大量无效解决方案（与输入输出示例一致，但不等价于参考解决方案）。我们注意到，基于组件的 DSR 综合策略不仅完整，而且高效。</p>
<h3 id="7-2-实例不足时的稳健性"><a href="#7-2-实例不足时的稳健性" class="headerlink" title="7.2 实例不足时的稳健性"></a>7.2 实例不足时的稳健性</h3><p>我们在两种基准上评估了 NetSpec 对示例不足的鲁棒性：(1) 示例不足的基准（表 3）；(2) 有足够原始示例的基准，但其中一些示例被随机删除了，以测试 NetSpec 的极限（Figure 7）。</p>
<p><em><strong>处理示例不足(Handling insufficient examples)</strong></em> 对于表 3 中的每个基准，我们使用主动学习功能运行 NetSpec。不断地向用户查询额外的输入示例，直到发现示例中没有歧义为止。为了确定主动学习阶段（第 5 节）的随机样本数<br>为了确定主动学习阶段（第 5 节）的随机样本数，我们将样本数从 1 个逐渐增加到 100 万个。并测量被 NetSpec 解决的基准数量。由于主动学习算法的随机性，如果一个基准在10次重复实验中均返回正确，则该基准被定义为成功。<br>图 6 显示了结果。在 100K 样本时达到饱和，18 个基准中有 15 个成功。其余三个基准涉及最复杂的规范。它们超时并返回不正确的规范（与输入输出示例一致，但与参考值不同）。之所以引入时间限制，是因为 NetSpec 是为交互式使用而设计的。回想一下，主动学习阶段涉及合成规范和生成新输入示例的多次迭代。其输出由协议设计人员注释。由于采样参数超过 100K并不能减少端到端时间（即不能帮助在时间预算内解决更多基准），因此我们使用100K 作为剩余实验的随机样本数和参数的的默认值。用户还可以根据自己的问题域确定该参数。表 3 显示了主动学习实验的详细统计数据。根据不同的基准，查询次数的中位数从 2 到 42.5 不等。同样，不同基准的端到端时间从 43 秒到 2,945秒。<br>对于三个超时的基准（2pc、rip 和 dsdv），它们的关系组成了一个更大的程序空间（规则中具有许多谓词和聚合器），因此需要更多的示例来明确说明。这导致主动学习中的迭代次数过多，而这正是以输入输出示例为基础的软件的限制。合成正确的规范减少查询次数或提高合成效率这仍是未来工作的一个有趣方向。</p>
<p><em><strong>随机省略示例(Randomly omitted examples)</strong></em> 我们进一步通过随机省略示例来对NetSpec进行压力测试。选择了至少有七个示例的三个基准进行此实验。对于每一个，示例会逐渐被删除，直到达到最极端的情况，即每个输出关系只出现在一个示例实例中。否则，一个输出关系会从所有示例中被遗漏，NetSpec将跳过为该关系合成规则，从而返回一个不完整的程序。<br>图7展示了每个基准在十次重复运行中查询次数和端到端主动学习时间的分布。查询次数与省略示例的数量呈正相关，只有一个例外。基准“temperature-report”显示出较弱的相关性，因为每次主动学习运行需要的查询次数（40 ± 5）比原始示例集的大小（9）要多。因此，省略示例的影响比查询总数较少的基准弱。<br>对于端到端时间和省略示例数量之间的关系，“firewall-l3”显示出强烈的正相关性。 “temperature-report”没有显示出相关性，这是预期的，因为其查询次数与省略示例的数量没有相关性（图7e）。另一方面，对于“subnet”基准，尽管省略示例的数量与查询次数（图7a）有强烈的相关性，但与时间（图7b）的相关性较弱。这是因为端到端时间主要由最后几次运行（其中示例几乎足够）的合成时间主导。早期运行速度快，因为只剩下几个示例，NetSpec可以快速找到表面解决方案并查询新示例。当示例足够时，解决方案变得更加复杂（规则中的文字更多）。这种复杂性，加上合成算法的随机性，导致合成时间的变化较大。<br>在“subnet”和“temperate-report”基准测试中，即使在只剩下1个示例的极端情况下，NetSpec也始终能够恢复经过验证的规范（100%）。另一方面，“Firewall-l3”在特定消息类型的所有示例都被删除时会失败。例如，如果没有示例响应ARP包，那么所有候选程序都会忽略ARP包，因为NetSpec会丢弃没有派生参考输出的规则，尽管参考程序实际上处理了ARP包。然而，在实践中，协议设计者对典型类型的输出完全没有提供示例的情况很少。</p>
<p>总的来说，NetSpec的主动学习机制在提高示例质量和找到经过验证的解决方案方面是有效的。程序的一般差异测试是一个困难的问题。然而，通过将协议逻辑与实现细节分离，声明性规范大大减少了区分备选规范的搜索空间。通过利用声明性规范的简单性，NetSpec的简单随机测试机制能够有效地消除备选协议规范的歧义。<br><em><strong>图 6</strong></em><br><img src="/NetSpec-paper/image(8).png"></p>
<p><em><strong>图 7</strong></em><br><img src="/NetSpec-paper/image(9).png"></p>
<h3 id="7-3-从程序痕迹中学习"><a href="#7-3-从程序痕迹中学习" class="headerlink" title="7.3 从程序痕迹中学习"></a>7.3 从程序痕迹中学习</h3><p>在我们的最后一个实验中，我们探索了NetSpec直接从实际执行跟踪作为输入输出示例进行合成的能力。这种方法的好处有两方面。首先，对于代码重构或程序分析，生成的规范揭示了程序的基本逻辑，并可以作为进一步分析的形式模型。其次，逻辑规范可以被编译成一个更紧凑、不那么臃肿的程序进行执行。</p>
<p><em><strong>跟踪收集(Trace colletion)</strong></em> 我们从两个流行的SDN平台，POX [32]和Floodlight [19]，收集程序通信跟踪，在这些平台上我们运行控制器程序并收集其与网络中的交换机的通信跟踪。由于可以轻松获取与我们的基准匹配的开源实现，我们选择SDN平台作为此实验的基础。<br>为了生成输入输出示例，我们生成代表性的流量负载并将其注入到每个SDN控制器程序中。基于这些输入，我们通过观察SDN程序来捕获输出。例如，对于学习交换机，所有主机发送探测包以在网络中建立完全的连通性。对于防火墙，我们将网络划分为两个区域，一个由防火墙保护，另一个作为外部网络。然后我们随机从网络的两侧选择主机建立TCP会话。我们通过检查只有从内部主机发起的会话才能成功建立来验证防火墙的功能。<br>通过在Mininet [29]模拟器上运行POX和Floodlight的控制器程序来完成跟踪收集。所有的Mininet拓扑都在一个16节点，8交换机，树形拓扑网络上设置。对于每次运行，我们收集控制器与Mininet交换机（通过传入&#x2F;传出数据包和流修改）交互时的输入输出跟踪。在我们所有的实验中，我们观察到这种设置足以收集足够的示例供NetSpec学习一个经过验证的规范，并向用户提出额外的查询。<br>我们在POX和Floodlight上实现了一个跟踪收集器，该收集器在运行时收集控制器的输入和输出消息以及程序的状态变化。状态监视器的工作方式如下。在每个应用程序的输入数据包处理器中，我们检查所有可访问的全局变量。然后我们记录这些全局变量的任何变化。我们排除了与每个应用程序的执行逻辑无关的已知全局构造，如日志记录器。<br>表4总结了结果。我们有以下观察。首先，NetSpec能够正确地合成所有应用程序的预期规范。其次，尽管跟踪包含多达4500条通信消息，但仍需要额外的查询来增加示例。这个观察显示了NetSpec的示例增强机制在帮助用户发现角落案例方面的实用性。第三，即使对于具有数百行代码的非平凡SDN应用程序，NetSpec也能够生成不超过七条规则的紧凑规范。最后，合成时间在数百秒的数量级，除了“学习开关”需要2295秒，尽管需要分析包含多达4591个示例的实际通信跟踪，并生成多个查询，这表明了我们方法的效率和可扩展性。</p>
<p><em><strong>表 4</strong></em><br><img src="/NetSpec-paper/image(11).png"></p>
<h2 id="八、相关工作"><a href="#八、相关工作" class="headerlink" title="八、相关工作"></a>八、相关工作</h2><p><em><strong>示例编程(Programming by example)</strong></em> . NetEgg通过示例时间图表实现SDN策略。NetEgg通过实际用户研究证明，示例编程可以提高编程效率并减少错误。关键的区别在于，NetSpec合成了目标DSL中的实际控制平面程序，由该程序生成数据平面配置，而NetEgg直接生成数据平面配置。这个目标DSL可以用来验证和检查控制平面程序中的错误，而NetEgg只能提供反例来表明输入示例是错误的。NetSpec改善了NetEgg的一个固有弱点，即要求用户提供满足场景所需的的所有可能示例。Facon是一个用于合成SDN程序的按示例编程工具。NetSpec采用了更可扩展的合成策略，针对更通用的逻辑模型，并且可以处理更复杂的协议和不完整的示例。</p>
<p><em><strong>网络配置合成 (Network configuration synthesis)</strong></em> . NetComplete [17] 以高级路由策略为输入，合成符合这些策略的BGP配置，Genesis [39] 则在多租户网络中合成转发表。Avenir [10] 从高级转发规范中合成SDN数据平面配置。Propane [7] 将高级路由策略编译成分布式路由器BGP配置。与这些工具不同，NetSpec 使用输入-输出示例，或来自遗留程序的执行跟踪作为输入，并生成与给定输入-输出示例一致的可执行协议规范。<br>Config2Spec [8] 以网络配置和故障模型为输入，生成适用于所有从给定配置和故障模型派生的具体数据平面的网络策略。另一方面，NetSpec 生成的是可执行规范（分析规则），而不是静态策略（从分析规则中得出的事实）。当对目标策略没有可用的分析工具时，NetSpec 可以补充 Config2Spec。NetSpec 以具体数据平面和一组满足的策略为输入，并生成可以应用于所有具体数据平面的数据平面分析规则。例如，在第7.1节中，我们展示了 NetSpec 可以在推断可达性策略时生成类似于 Config2Spec 所使用的可达性分析规则。</p>
<p><em><strong>Datalog和逻辑程序合成</strong></em> 大量的工作提出从输入-输出示例中合成逻辑程序[15]的技术。除了GenSynth外，现有的技术需要用户通过诸如模式声明（例如，ILASP [24]）、元规则（例如，Metagol [16]）、候选规则（例如，ALPS [36]和ProSynth [33]）或模板（例如，NTP [34]和δILP [18]）等规范来在语法上限制搜索空间。NetSpec不需要用户提供任何此类规范，但需要更多的输入-输出示例来完全指定一个预期程序。然而，在主动学习的帮助下，如我们的评估所示，NetSpec合成的程序比GenSynth更通用，并且更高效、更稳健。</p>
<p><em><strong>网络验证和特定领域的语言(DSLs)</strong></em> 先前大量的工作，如网络验证 [22]、[20]、[6]、[40]、[41] 和网络 DSLs [31]、[21]、[23]、[5]。NetSpec 生成的逻辑网络规范可以使用现有技术进行验证。因此，应将验证视为与 NetSpec 互补的技术。拥有受限语言的同样好处，如可扩展的合成和自动化示例增强，也适用于其他 DSLs。</p>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>NetSpec 解决了网络验证中的一个长期问题：形式模型与实际实现之间的差距日益扩大。作为缩小这个差距的一步，我们提出了一个新的示例规范（SBE）工具包，用户可以从输入-输出示例中构建他们的网络协议的形式模型，这些示例要么由网络设计者提供，要么从遗留实现中提取。我们合成的模型是声明性逻辑程序，适合进行正式验证，甚至生成分布式实现。<br>我们的初步尝试和实验结果是有希望的。示例规范（SBE）方法可以有效地合成各种网络协议，并且对缺失的示例具有鲁棒性。NetSpec 应被视为理解 SBE 范式及其在网络不同领域中的应用的第一步，尽管在合成规范的大小和复杂性上存在限制。在未来，我们计划探索如何合成更复杂的规范，如何并行化合成算法以处理更大的规范，以及 SBE 如何与不同的形式验证技术交互。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Zhu He</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://mendax0725.github.io/2023/09/28/NetSpec-paper/">https://mendax0725.github.io/2023/09/28/NetSpec-paper/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zhu He | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>